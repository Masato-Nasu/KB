<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Baby Shapes Neon — ジェスチャー表示 (v1.3.2)</title>
<link rel="manifest" href="./manifest.json?v=1.3.2">
<meta name="theme-color" content="#1a1a1a">
<style>
  :root{ --bg:#1a1a1a; --panel:#20232bcc; --text:#E8EAF2; --muted:#8b90a1; --boxw:1100px; --pad:16px;}
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Roboto,"Noto Sans JP",sans-serif;}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;min-height:100%; padding:12px}
  .box{ width: min(var(--boxw), calc(100% - 2*var(--pad))); margin:0 auto; border-radius:24px; overflow:hidden; box-shadow:0 12px 36px rgba(0,0,0,.35); }
  .stage{ position:relative; display:grid; place-items:center; aspect-ratio:1; background:var(--bg); }
  canvas{width:100%;height:100%;display:block;touch-action:none;background:var(--bg)}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center; padding:12px; background:var(--panel); backdrop-filter:saturate(1.05) blur(6px); transition:opacity .25s ease, visibility .25s ease;}
  .btn{appearance:none;border:0;border-radius:14px;background:#2f6feb;color:#fff; padding:12px 16px;font-size:16px;display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .range{display:inline-flex;align-items:center;gap:10px;background:#0f1117; color:#E8EAF2; border-radius:14px;padding:10px 12px; box-shadow:0 2px 8px rgba(0,0,0,.25)}
  input[type="range"]{width:160px}
  .muted{color:var(--muted);font-size:12px;margin-top:-6px;text-align:center}
  /* 再生モード（全画面） */
  .fullscreen .wrap{padding:0}
  .fullscreen .box{width:100%; border-radius:0; box-shadow:none;}
  .fullscreen .stage{aspect-ratio:auto; width:100vw; height:100dvh;}
  .hidden{opacity:0; visibility:hidden; pointer-events:none}
  /* ヒント（画面左下に薄く） */
  .hint{position:fixed;left:10px;bottom:10px;font-size:12px;color:#999}
</style>
</head>
<body>
<div class="wrap">
  <div class="box"><div class="stage" id="stage"><canvas id="cv"></canvas></div></div>
  <div class="box">
    <div class="controls" id="controls">
      <label class="btn">🎵 おんがくフォルダ<input id="audDir" type="file" webkitdirectory directory multiple accept="audio/*" hidden></label>
      <button id="prev" class="btn">← まえ</button>
      <button id="play" class="btn">▶ / ❚❚</button>
      <button id="next" class="btn">つぎ →</button>
      <div class="range">かず <input id="count" type="range" min="3" max="50" step="1" value="22"></div>
      <div class="range">せんの太さ <input id="thick" type="range" min="2" max="14" step="1" value="6"></div>
      <div class="range">ひかり <input id="glow" type="range" min="8" max="60" step="1" value="28"></div>
    </div>
  </div>
  <div class="muted">v1.3.2: 画面ボタンを消し、<b>「2本指で長押し(0.8秒)」</b>で設定を表示/非表示。Androidの歪み/振る反応は前版の修正を継承。</div>
</div>
<div class="hint">ヒント: 2本指で0.8秒タッチ→設定</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');
  const controls = document.getElementById('controls');
  const countUI = document.getElementById('count');
  const thickUI = document.getElementById('thick');
  const glowUI  = document.getElementById('glow');
  const hintEl = document.querySelector('.hint');

  // --- 物理ボタン検出はWebでは不可 → 代替のジェスチャーで対応 ---
  // 2本指で0.8秒長押し → 設定トグル
  let activePointers = new Map();
  let holdTimer = null;
  let holding = false;
  function onPointerDown(e){
    activePointers.set(e.pointerId, {x:e.clientX,y:e.clientY,time:performance.now()});
    if(activePointers.size>=2 && !holdTimer){
      holdTimer = setTimeout(()=>{
        holding = true;
        controls.classList.toggle('hidden');
        // ヒントは1回出したら消す
        if(!controls.classList.contains('hidden')){ hintEl.style.display='none'; }
      }, 800);
    }
  }
  function cancelHold(){
    if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }
    holding=false;
  }
  function onPointerUp(e){ activePointers.delete(e.pointerId); cancelHold(); }
  function onPointerMove(e){
    // 大きく動いたらキャンセル（誤爆防止）
    const p=activePointers.get(e.pointerId);
    if(p){
      const dx=Math.abs(e.clientX-p.x), dy=Math.abs(e.clientY-p.y);
      if(dx>20 || dy>20) cancelHold();
    }
  }
  ['pointerdown','pointerup','pointercancel','pointermove'].forEach(ev=>{
    stage.addEventListener(ev, (e)=>{
      if(ev==='pointerdown') onPointerDown(e);
      if(ev==='pointerup' || ev==='pointercancel') onPointerUp(e);
      if(ev==='pointermove') onPointerMove(e);
    }, {passive:false});
  });

  // 初回操作時にフルスクリーンへ（再生モード想定）
  stage.addEventListener('pointerdown', async ()=>{
    if(!document.fullscreenElement){
      try{ await document.documentElement.requestFullscreen(); document.body.classList.add('fullscreen'); }catch(_){}
    }
  }, {once:true});

  // palette
  const COLORS = ["#39FF14","#00FFFF","#FF4D6D","#FFD166","#9D4DFF"];
  const BG = "#1a1a1a";

  // ===== Audio (continuous) =====
  let audList=[], audIdx=0, audio=new Audio(); audio.preload="auto";
  let actx, analyser, data, playing=false;
  function ensureAudio(){
    if(actx) return;
    actx = new (window.AudioContext||window.webkitAudioContext)();
    const src = actx.createMediaElementSource(audio);
    analyser = actx.createAnalyser(); analyser.fftSize=256;
    data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser); analyser.connect(actx.destination);
  }
  ['click','touchstart','pointerdown'].forEach(ev=>{
    window.addEventListener(ev, async ()=>{ ensureAudio(); try{ if(actx.state!=='running') await actx.resume(); }catch(_){ } }, {once:true, passive:true});
  });
  function naturalSort(a,b){ return a.name.localeCompare(b.name,'ja',{numeric:true}); }
  document.getElementById('audDir').addEventListener('change', e=>{
    ensureAudio();
    audList = [...e.target.files].filter(f=>f.type.startsWith('audio/')).sort(naturalSort);
    audIdx=0; if(audList.length) playIndex(audIdx);
  });
  async function playIndex(i){
    if(!audList.length) return;
    audio.src = URL.createObjectURL(audList[i]);
    try{ if(actx.state!=='running') await actx.resume(); await audio.play(); playing=true; }catch(e){}
  }
  document.getElementById('next').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx+1)%audList.length; playIndex(audIdx); });
  document.getElementById('prev').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx-1+audList.length)%audList.length; playIndex(audIdx); });
  document.getElementById('play').addEventListener('click', async ()=>{
    ensureAudio(); if(actx.state!=='running') await actx.resume();
    if(audio.paused){ await audio.play(); playing=true; } else { audio.pause(); playing=false; }
  });
  audio.addEventListener('ended', ()=>{
    if(audList.length){ audIdx=(audIdx+1)%audList.length; playIndex(audIdx); }
    else { audio.currentTime=0; audio.play(); }
  });

  // ===== Canvas sizing (歪み対策)
  const dprCap=1.5;
  function vpSize(){
    const vv = window.visualViewport;
    return vv ? { w: Math.floor(vv.width), h: Math.floor(vv.height) } : { w: window.innerWidth, h: window.innerHeight };
  }
  function fit(full){
    const dpr=Math.min(window.devicePixelRatio||1, dprCap);
    if(full || document.fullscreenElement){
      const {w,h}=vpSize();
      cv.width = Math.max(360, Math.floor(w*dpr));
      cv.height = Math.max(360, Math.floor(h*dpr));
    }else{
      const s=Math.min(stage.clientWidth, stage.clientHeight);
      cv.width=cv.height=Math.max(360,Math.floor(s*dpr));
    }
  }
  const ro=new ResizeObserver(()=>fit()); ro.observe(stage); fit();
  window.addEventListener('resize', ()=>fit(), {passive:true});
  if(window.visualViewport){ visualViewport.addEventListener('resize', ()=>fit(), {passive:true}); }

  // ===== Shapes
  const TYPES = ["circle","triangle","square","star","heart"];
  function starPath(r, spikes=5){ const p=new Path2D(); const step=Math.PI/spikes; p.moveTo(r,0); for(let i=0;i<spikes*2;i++){ const rr=(i%2===0)?r:r*0.45; const a=i*step; p.lineTo(Math.cos(a)*rr,Math.sin(a)*rr);} p.closePath(); return p; }
  function heartPath(r){ const p=new Path2D(); p.moveTo(0,-r*0.2); p.bezierCurveTo(r*0.9,-r*0.9, r*1.4,r*0.5, 0,r*1.2); p.bezierCurveTo(-r*1.4,r*0.5, -r*0.9,-r*0.9, 0,-r*0.2); return p; }
  const starCache=new Map(), heartCache=new Map();
  function getStar(r){ const k=r|0; if(!starCache.has(k)) starCache.set(k, starPath(k)); return starCache.get(k); }
  function getHeart(r){ const k=r|0; if(!heartCache.has(k)) heartCache.set(k, heartPath(k)); return heartCache.get(k); }

  const shapes=[];
  function resetShapes(){
    shapes.length=0;
    const n=Math.max(3, (countUI.value|0));
    for(let i=0;i<n;i++){
      const type=TYPES[i%TYPES.length];
      const r=70*(0.6+Math.random()*0.6);
      const x=Math.random()*cv.width, y=Math.random()*cv.height;
      const rot=Math.random()*Math.PI*2;
      const vx=(Math.random()-0.5)*0.5, vy=(Math.random()-0.5)*0.5;
      const color=COLORS[i%COLORS.length];
      shapes.push({type,x,y,r,rot,vx,vy,pulse:0,color});
    }
  }
  countUI.addEventListener('input', resetShapes); resetShapes();

  // interaction: scatter ALL on touch
  const chime = new Audio("./Chime.mp3"); chime.volume = 0.45;
  function toLocal(e){ const r=stage.getBoundingClientRect(); return { x:(e.clientX-r.left)/r.width*cv.width, y:(e.clientY-r.top)/r.height*cv.height }; }
  stage.addEventListener('pointerdown', (e)=>{
    const p=toLocal(e);
    for(const s of shapes){
      const ang=Math.atan2(s.y-p.y, s.x-p.x);
      const force=3.2 + Math.random()*1.8;
      s.vx += Math.cos(ang)*force; s.vy += Math.sin(ang)*force;
      s.pulse = Math.min(1, s.pulse+0.9);
    }
    try{ chime.currentTime=0; chime.play(); }catch(_){}
  });

  // ANDROID motion permission
  async function requestMotionPermission(){
    try{
      if (typeof DeviceMotionEvent !== 'undefined' && DeviceMotionEvent.requestPermission){
        const r = await DeviceMotionEvent.requestPermission(); console.log('DeviceMotion perm:', r);
      }
    }catch(_){}
  }
  document.addEventListener('pointerdown', requestMotionPermission, {once:true});

  if (window.DeviceMotionEvent){
    let last=0;
    window.addEventListener('devicemotion', (e)=>{
      const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0;
      const s=Math.sqrt(x*x+y*y+z*z);
      if(s>18 && Date.now()-last>900){
        const cx=cv.width/2, cy=cv.height/2;
        for(const sh of shapes){
          const ang=Math.atan2(sh.y-cy, sh.x-cx);
          const force = 2.6 + Math.random()*1.6;
          sh.vx += Math.cos(ang)*force;
          sh.vy += Math.sin(ang)*force;
          sh.pulse = Math.min(1, sh.pulse+0.8);
        }
        try{ chime.currentTime=0; chime.play(); }catch(_){}
        last=Date.now();
      }
    }, {passive:true});
  }

  // ===== draw
  let t=0;
  function draw(){
    const w=cv.width,h=cv.height;
    ctx.fillStyle=BG; ctx.fillRect(0,0,w,h);
    let low=0,mid=0,hi=0;
    if(analyser){ analyser.getByteFrequencyData(data); const n=data.length; for(let i=0;i<n;i++){ const v=data[i]/255; if(i<n*0.33) low+=v; else if(i<n*0.66) mid+=v; else hi+=v; } low/=n*0.33; mid/=n*0.33; hi/=n*0.34; }
    const lineBase=parseFloat(thickUI.value); const glow=parseFloat(glowUI.value);
    for(const s of shapes){
      s.x+=s.vx; s.y+=s.vy; s.rot+=0.008*(0.6+mid);
      if(s.x<s.r){ s.x=s.r; s.vx=Math.abs(s.vx); } if(s.x>w-s.r){ s.x=w-s.r; s.vx=-Math.abs(s.vx); }
      if(s.y<s.r){ s.y=s.r; s.vy=Math.abs(s.vy); } if(s.y>h-s.r){ s.y=h-s.r; s.vy=-Math.abs(s.vy); }
      s.vx*=0.992; s.vy*=0.992;
      const scale = 1 + 0.07*Math.sin(t*0.03 + s.x*0.003) + s.pulse*0.25 + hi*0.1;
      const r = s.r * scale; s.pulse *= 0.92;
      ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rot);
      ctx.lineJoin="round"; ctx.lineCap="round";
      ctx.shadowColor=s.color; ctx.shadowBlur=glow*2; ctx.strokeStyle=s.color; ctx.lineWidth=lineBase*2.4; drawShapeStroke(s.type,r);
      ctx.shadowBlur=glow; ctx.lineWidth=lineBase*1.5; drawShapeStroke(s.type,r);
      ctx.shadowBlur=glow*0.3; ctx.strokeStyle="#ffffff"; ctx.lineWidth=Math.max(1,lineBase*0.6); drawShapeStroke(s.type,r);
      ctx.restore();
    }
    t++; requestAnimationFrame(draw);
  }
  function drawShapeStroke(type,r){
    switch(type){
      case "circle": ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); break;
      case "triangle": ctx.beginPath(); const h=r*1.1; ctx.moveTo(0,-h); ctx.lineTo(h*Math.sin(Math.PI/3), h*Math.cos(Math.PI/3)); ctx.lineTo(-h*Math.sin(Math.PI/3), h*Math.cos(Math.PI/3)); ctx.closePath(); ctx.stroke(); break;
      case "square": ctx.strokeRect(-r,-r,r*2,r*2); break;
      case "star": ctx.stroke(getStar(r)); break;
      case "heart": ctx.stroke(getHeart(r)); break;
    }
  }
  requestAnimationFrame(draw);
})();
</script>
<script>
if("serviceWorker" in navigator){ navigator.serviceWorker.register("./sw.js?v=1.3.2"); }
</script>
</body>
</html>
