<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Aurora Ribbons — motion & audio reactive</title>
<link rel="manifest" href="./manifest.json?v=1">
<style>
  :root{ --bg:#0b0c10; --panel:#0f1117; --text:#e8e9ee; --muted:#8b90a1; }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; }
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;min-height:100%}
  .stage{position:relative;display:grid;place-items:center;width:100%;max-width:1100px;aspect-ratio:1;background:#000;border-radius:18px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  canvas{width:100%;height:100%;display:block}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center;
    padding:12px;background:var(--panel);border-radius:12px;margin:8px;max-width:1100px}
  .btn{appearance:none;border:0;border-radius:12px;background:#171a20;color:#eaeef8;
    padding:10px 14px;display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .range{display:inline-flex;align-items:center;gap:8px;background:#171a20;color:#eaeef8;border-radius:12px;padding:10px 12px}
  input[type="range"]{width:140px}
  .muted{color:var(--muted);font-size:12px;margin-top:-6px;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <div class="stage" id="stage"><canvas id="cv"></canvas></div>
  <div class="controls">
    <label class="btn">🎵 音楽フォルダ<input id="audDir" type="file" webkitdirectory directory multiple accept="audio/*" hidden></label>
    <button id="prev" class="btn">← 前</button>
    <button id="play" class="btn">▶ / ❚❚</button>
    <button id="next" class="btn">次 →</button>
    <div class="range">帯の本数<input id="ribbons" type="range" min="3" max="24" step="1" value="10"></div>
    <div class="range">しなり<input id="flex" type="range" min="0.2" max="1.5" step="0.05" value="0.9"></div>
  </div>
  <div class="muted">Aurora Ribbons v1: スマホの振り・傾き・音に反応して発光リボンが流れます。PWA対応。</div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = true;
  const stage = document.getElementById('stage');
  const ribbonsUI = document.getElementById('ribbons');
  const flexUI  = document.getElementById('flex');

  // ===== Audio =====
  let audList=[], audIdx=0, audio=new Audio(); audio.preload="auto";
  let actx, analyser, data, playing=false;
  function ensureAudio(){
    if(actx) return;
    actx = new (window.AudioContext||window.webkitAudioContext)();
    const src = actx.createMediaElementSource(audio);
    analyser = actx.createAnalyser(); analyser.fftSize=256;
    data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser); analyser.connect(actx.destination);
  }
  function naturalSort(a,b){ return a.name.localeCompare(b.name,'ja',{numeric:true}); }
  document.getElementById('audDir').addEventListener('change', e=>{
    ensureAudio();
    audList = [...e.target.files].filter(f=>f.type.startsWith('audio/')).sort(naturalSort);
    audIdx=0; if(audList.length) playIndex(audIdx);
  });
  async function playIndex(i){
    if(!audList.length) return;
    audio.src = URL.createObjectURL(audList[i]);
    try{ if(actx.state!=="running") await actx.resume(); await audio.play(); playing=true; }catch(e){}
  }
  document.getElementById('next').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx+1)%audList.length; playIndex(audIdx); });
  document.getElementById('prev').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx-1+audList.length)%audList.length; playIndex(audIdx); });
  document.getElementById('play').addEventListener('click', async ()=>{
    ensureAudio(); if(actx.state!=="running") await actx.resume();
    if(audio.paused){ await audio.play(); playing=true; } else { audio.pause(); playing=false; }
  });

  // ===== Canvas sizing =====
  const dprCap=1.2;
  function fit(){
    const s=Math.min(stage.clientWidth, stage.clientHeight);
    const dpr=Math.min(window.devicePixelRatio||1, dprCap);
    cv.width=cv.height=Math.max(300,Math.floor(s*dpr));
  }
  const ro=new ResizeObserver(()=>fit()); ro.observe(stage); fit();
  let lastDPR=window.devicePixelRatio; setInterval(()=>{ if(window.devicePixelRatio!==lastDPR){ lastDPR=window.devicePixelRatio; fit(); } }, 600);

  // ===== Motion (shake/tilt) =====
  let tiltX=0, tiltY=0, shake=0, lastShake=0;
  function reqMotionPerm(){
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        DeviceMotionEvent.requestPermission().catch(()=>{});
      }
    }catch(e){}
  }
  stage.addEventListener('click', reqMotionPerm, {passive:true});
  if (window.DeviceMotionEvent){
    window.addEventListener('devicemotion', (e)=>{
      const a=e.accelerationIncludingGravity||{};
      const x=a.x||0,y=a.y||0,z=a.z||0;
      const s=Math.sqrt(x*x+y*y+z*z);
      tiltX = x*0.03; tiltY = y*0.03;
      if (s>18 && Date.now()-lastShake>800){ shake = Math.min(1, shake+0.6); lastShake=Date.now(); }
    }, {passive:true});
  }
  // Fade shake
  setInterval(()=>{ shake *= 0.92; }, 50);

  // ===== Simple 2D noise (value noise) =====
  const perm = new Uint8Array(512);
  for(let i=0;i<256;i++) perm[i]=i;
  for(let i=255;i>0;i--){ const j=(Math.random()*i)|0; [perm[i],perm[j]]=[perm[j],perm[i]]; }
  for(let i=0;i<256;i++) perm[256+i]=perm[i];
  function fade(t){ return t*t*(3-2*t); }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function vnoise(x,y){
    const xi=Math.floor(x)&255, yi=Math.floor(y)&255;
    const xf=x-Math.floor(x), yf=y-Math.floor(y);
    const aa=perm[perm[xi]+yi], ab=perm[perm[xi]+yi+1];
    const ba=perm[perm[xi+1]+yi], bb=perm[perm[xi+1]+yi+1];
    const u=fade(xf), v=fade(yf);
    const x1=lerp(aa/255, ba/255, u);
    const x2=lerp(ab/255, bb/255, u);
    return lerp(x1,x2,v);
  }

  // ===== Ribbons model =====
  const MAX_POINTS = 180;
  let ribbons=[];
  function resetRibbons(){
    ribbons.length=0;
    const count=parseInt(ribbonsUI.value,10);
    for(let i=0;i<count;i++){
      const hue=(200 + 100*i/count)|0;
      const pts=[];
      for(let k=0;k<MAX_POINTS;k++) pts.push({x:0,y:0});
      const speed=0.002 + 0.001*i/count;
      ribbons.push({hue, pts, t:Math.random()*1000, speed});
    }
  }
  ribbonsUI.addEventListener('input', resetRibbons);
  resetRibbons();

  let t=0;
  function draw(){
    const w=cv.width,h=cv.height; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2;
    ctx.globalCompositeOperation="source-over";
    ctx.fillStyle="rgba(0,0,0,0.2)"; // トレイルで残像
    ctx.fillRect(0,0,w,h);

    // audio energy
    let low=0, mid=0, hi=0;
    if(analyser && playing){
      analyser.getByteFrequencyData(data);
      const n=data.length;
      for(let i=0;i<n;i++){
        const v=data[i]/255;
        if(i<n*0.33) low+=v; else if(i<n*0.66) mid+=v; else hi+=v;
      }
      low/=n*0.33; mid/=n*0.33; hi/=n*0.34;
    }

    const flex=parseFloat(flexUI.value);
    const timeScale = 0.0008 + hi*0.0006 + shake*0.0012;

    ctx.globalCompositeOperation="lighter";
    for(const rb of ribbons){
      rb.t += rb.speed + timeScale;
      const pts=rb.pts;
      // 先頭位置（中心から外へ）
      const angle = Math.PI*2 * vnoise(rb.t*0.15 + tiltX*0.5, rb.t*0.12 + tiltY*0.5);
      const radius = R* (0.15 + 0.75*vnoise(rb.t*0.1 + 10, rb.t*0.1 - 10));
      const headX = cx + Math.cos(angle)*radius + tiltX*R*0.6;
      const headY = cy + Math.sin(angle)*radius + tiltY*R*0.6;
      // 末尾へシフト
      for(let i=pts.length-1;i>0;i--) { pts[i].x=pts[i-1].x; pts[i].y=pts[i-1].y; }
      pts[0].x=headX; pts[0].y=headY;

      // 描画（太さは低域、発光は中域、スパークはshake）
      const thickness = Math.max(1.2, R*(0.002 + 0.006*flex) * (1 + low*0.8 + shake*0.6));
      const alpha = 0.06 + 0.14*mid + 0.2*shake;
      const hue = (rb.hue + 30*hi + 50*shake) % 360;

      // 多重ストロークで柔らかい帯
      for(let k=4;k>=0;k--){
        ctx.strokeStyle = `hsla(${hue} 90% 60% / ${alpha * (1 - k*0.18)})`;
        ctx.lineWidth = thickness * (1 + k*0.6);
        ctx.beginPath();
        for(let i=0;i<pts.length;i++){
          const p=pts[i];
          const nx = p.x + (vnoise(p.x*0.003 + t*0.2, p.y*0.003 - t*0.2)-0.5)*flex*8;
          const ny = p.y + (vnoise(p.x*0.003 - t*0.2, p.y*0.003 + t*0.2)-0.5)*flex*8;
          if(i===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
        }
        ctx.stroke();
      }
    }
    ctx.globalCompositeOperation="source-over";

    t += 0.016;
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
<script>
// SW
if("serviceWorker" in navigator){ navigator.serviceWorker.register("./sw.js?v=1"); }
</script>
</body>
</html>
