<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>四角い穴の下で大円盤が回る／最終版</title>

<style>
  :root{--bg:#0b0d11;--fg:#e8f0ff;--muted:#9fb6d9}
  html,body{height:100%;margin:0;background:#0b0d11;color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto;justify-items:center;align-items:center}
  .stage{position:relative;display:grid;place-items:center;width:100%;height:100%}
  canvas{display:block;position:absolute;inset:0;margin:auto}
  /* 正方形に見せるための中央配置とサイズ調整 */
  #box{position:relative;aspect-ratio:1/1;width:min(90vmin, calc(100vw - 32px));}
  #bg,#mask{width:100%;height:100%}
  .bar{width:100%;display:flex;gap:.6rem;flex-wrap:wrap;align-items:center;justify-content:center;padding:.7rem;background:linear-gradient(180deg, rgba(14,18,24,.55), rgba(14,18,24,.95));backdrop-filter:blur(6px);border-top:1px solid #1c2635}
  .btn{background:#0f1a27;border:1px solid #263244;color:var(--fg);padding:.55rem .8rem;border-radius:.8rem;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  input[type=file]{display:none}
  label.file{cursor:pointer}
  .group{display:inline-flex;align-items:center;gap:.35rem}
  .pill{color:var(--muted);font-size:.9rem}
</style>
</head>
<body>
<div id="wrap">
  <div class="stage">
    <div id="box">
      <!-- 下：回転する円盤（背景キャンバス） -->
      <canvas id="bg" width="1024" height="1024"></canvas>
      <!-- 上：黒い板。中央に正方形の穴を開ける（透過） -->
      <canvas id="mask" width="1024" height="1024"></canvas>
    </div>
  </div>

  <div class="bar">
    <input id="imgFile" type="file" accept="image/*">
    <label for="imgFile" class="btn file">📷 画像</label>
    <button id="testImgBtn" class="btn">🧪 テスト画像</button>
    <button id="clearImg" class="btn">画像クリア</button>

    <div class="group">
      <label>分割 N×N</label>
      <input id="gridN" type="range" min="1" max="32" value="12">
      <span id="gridNV">12</span>
    </div>
    <div class="group">
      <label>放射セグメント</label>
      <input id="segs" type="range" min="6" max="72" value="24">
      <span id="segsV">24</span>
    </div>
    <div class="group">
      <label>穴サイズ</label>
      <input id="hole" type="range" min="50" max="98" value="86">
      <span id="holeV">86%</span>
    </div>

    <label class="group">
      <input type="checkbox" id="chimeOn"> 🔔キャンバスクリックでChime
    </label>
  </div>
</div>

<script>
/* ========= DOM / Canvas ========= */
const bg = document.getElementById('bg');
const bk = bg.getContext('2d');
const mask = document.getElementById('mask');
const mk = mask.getContext('2d');

const gridNEl = document.getElementById('gridN');
const gridNV = document.getElementById('gridNV');
const segsEl = document.getElementById('segs');
const segsV = document.getElementById('segsV');
const holeEl = document.getElementById('hole');
const holeV = document.getElementById('holeV');
const chimeOn = document.getElementById('chimeOn');

let GRID = +gridNEl.value;
let SEGS = +segsEl.value;
let HOLE = +holeEl.value; // % of box side

/* ========= Audio (click chime) ========= */
let audioCtx=null;
const chime = new Audio('https://raw.githubusercontent.com/Masato-Nasu/KB/main/Chime.mp3');
async function ensureAC(){ if(!audioCtx){const AC=window.AudioContext||window.webkitAudioContext; audioCtx=new AC();} if(audioCtx.state==='suspended') await audioCtx.resume(); }
bg.addEventListener('click', async () => { if(!chimeOn.checked) return; await ensureAC(); chime.currentTime=0; try{ await chime.play(); }catch{} });
mask.addEventListener('click', async () => { if(!chimeOn.checked) return; await ensureAC(); chime.currentTime=0; try{ await chime.play(); }catch{} });

/* ========= Pattern source (build N×N mirror from 1 image) ========= */
let baseImg=null;
let pat=null, pctx=null;

function coverSrc(iw,ih,dw,dh,dx=0,dy=0,zoom=1){
  const s=Math.max(dw/iw, dh/ih)*zoom;
  const vw=dw/s, vh=dh/s;
  const mx=Math.max(0,(iw-vw)/2), my=Math.max(0,(ih-vh)/2);
  const sx=(iw-vw)/2 + Math.max(-mx,Math.min(mx,dx*mx));
  const sy=(ih-vh)/2 + Math.max(-my,Math.min(my,dy*my));
  return {sx,sy,sw:vw,sh:vh};
}

function rebuildPattern(){
  if(!baseImg) return;
  const w=bg.width, h=bg.height;
  if(!pat){ pat=document.createElement('canvas'); pctx=pat.getContext('2d'); }
  pat.width=w; pat.height=h;

  const t=performance.now();
  const dx=Math.sin(t*0.00023)*0.9, dy=Math.cos(t*0.00019)*0.9, zoom=1+0.06*Math.sin(t*0.00011);
  const src=coverSrc(baseImg.width, baseImg.height, w, h, dx, dy, zoom);

  const tw=w/GRID, th=h/GRID, sw=src.sw/GRID, sh=src.sh/GRID;
  pctx.clearRect(0,0,w,h);
  for(let gy=0; gy<GRID; gy++){
    for(let gx=0; gx<GRID; gx++){
      const dxp=gx*tw, dyp=gy*th, sxi=src.sx+gx*sw, syi=src.sy+gy*sh;
      pctx.save();
      pctx.translate(dxp+tw/2, dyp+th/2);
      pctx.scale(gx%2?-1:1, gy%2?-1:1);
      pctx.drawImage(baseImg, sxi, syi, sw, sh, -tw/2, -th/2, tw, th);
      pctx.restore();
    }
  }
}

/* ========= Draw: big rotating disc UNDER square hole ========= */
let angle=0;
function draw(){
  const w=bg.width, h=bg.height;
  bk.clearRect(0,0,w,h);

  if(pat){
    const cx=w/2, cy=h/2;
    const slice=(Math.PI*2)/SEGS;

    // 円盤半径は「対角/2 より大きく」= 四隅の裏まで必ず届く
    const R = Math.hypot(w,h)*0.55;      // 0.53〜0.60で好み調整
    const wedgeR = Math.hypot(w,h);      // 扇は対角ぶん伸ばす

    bk.save();
    bk.translate(cx,cy);

    // 円でクリップ：ここが「円盤」
    bk.beginPath(); bk.arc(0,0,R,0,Math.PI*2); bk.clip();

    for(let i=0;i<SEGS;i++){
      bk.save();
      bk.rotate(i*slice + angle);
      bk.beginPath();
      bk.moveTo(0,0);
      bk.lineTo(wedgeR, -wedgeR*Math.tan(slice/2));
      bk.lineTo(wedgeR,  wedgeR*Math.tan(slice/2));
      bk.closePath(); bk.clip();
      const flip = (i%2===1)?-1:1;
      bk.scale(flip,1);
      bk.drawImage(pat, -w/2, -h/2, w, h);
      bk.restore();
    }
    bk.restore();

    // 回転
    angle += 0.0025 * (24/Math.max(12,SEGS));
  }

  // === 上の黒い板（四角）に「正方形の穴」を開ける ===
  mk.clearRect(0,0,w,h);
  mk.save();
  // まず真っ黒で全体を塗る
  mk.fillStyle = '#000';
  mk.fillRect(0,0,w,h);
  // 穴を「くり抜く」
  mk.globalCompositeOperation='destination-out';
  const side = Math.floor(Math.min(w,h) * (HOLE/100)); // %で指定
  mk.fillRect((w-side)/2, (h-side)/2, side, side);
  mk.restore();

  requestAnimationFrame(tick);
}

function tick(){
  if(baseImg) rebuildPattern();
  draw();
}

/* ========= Fit both canvases ========= */
function fit(){
  const ratio = Math.min(window.innerWidth, window.innerHeight-88);
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const px = Math.floor(ratio * dpr);
  bg.width=bg.height=mask.width=mask.height=px;
  bg.style.width=bg.style.height=mask.style.width=mask.style.height=(ratio)+'px';
}
addEventListener('resize', fit); fit();

/* ========= Loaders ========= */
function loadImgFile(f){
  if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = ()=>{ baseImg=im; URL.revokeObjectURL(url); };
  im.src = url;
}
document.getElementById('imgFile').addEventListener('change', e=>loadImgFile(e.target.files[0]));

document.getElementById('testImgBtn').addEventListener('click', ()=>{
  const svg=`<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="1024" viewBox="0 0 1024 1024">
    <defs>
      <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#fff"/><stop offset="50%" stop-color="#f7b65a"/><stop offset="100%" stop-color="#3aa0ff"/>
      </linearGradient>
      <pattern id="p" width="64" height="64" patternUnits="userSpaceOnUse">
        <rect width="64" height="64" fill="url(#g)"/>
        <path d="M0 32 H64 M32 0 V64" stroke="rgba(0,0,0,.18)" stroke-width="2"/>
      </pattern>
    </defs>
    <rect width="1024" height="1024" fill="url(#p)"/></svg>`;
  const url='data:image/svg+xml;utf8,'+encodeURIComponent(svg);
  const im=new Image();
  im.onload=()=>{ baseImg=im; };
  im.src=url;
});
document.getElementById('clearImg').addEventListener('click', ()=>{ baseImg=null; pat=null; });

/* ========= UI ========= */
gridNEl.addEventListener('input', ()=>{ GRID=+gridNEl.value; gridNV.textContent=GRID; });
segsEl.addEventListener('input', ()=>{ SEGS=+segsEl.value; segsV.textContent=SEGS; });
holeEl.addEventListener('input', ()=>{ HOLE=+holeEl.value; holeV.textContent=HOLE+'%'; });

/* ========= Boot ========= */
document.getElementById('testImgBtn').click(); // 起動時に見えるように
requestAnimationFrame(tick);
</script>
</body>
</html>
