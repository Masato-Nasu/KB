<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Baby Shapes Neon — ひかる せんが 〇△□☆♡ (v1.2)</title>
<link rel="manifest" href="./manifest.json?v=1.2">
<meta name="theme-color" content="#1a1a1a">
<style>
  :root{ --bg:#1a1a1a; --panel:#20232bcc; --text:#E8EAF2; --muted:#8b90a1; }
  html,body{ height:100%; margin:0; background:var(--bg);
    color:var(--text); font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; }
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;min-height:100%}
  .stage{position:relative;display:grid;place-items:center;width:100%;max-width:1100px;aspect-ratio:1;
    background:var(--bg);border-radius:24px;overflow:hidden;box-shadow:0 12px 36px rgba(0,0,0,.35)}
  canvas{width:100%;height:100%;display:block;touch-action:none;background:var(--bg)}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center;
    padding:12px;background:var(--panel);backdrop-filter:saturate(1.05) blur(6px);
    border-radius:16px;margin:8px;max-width:1100px}
  .btn{appearance:none;border:0;border-radius:14px;background:#2f6feb;color:#fff;
    padding:12px 16px;font-size:16px;display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .range{display:inline-flex;align-items:center;gap:10px;background:#0f1117; color:#E8EAF2;
    border-radius:14px;padding:10px 12px; box-shadow:0 2px 8px rgba(0,0,0,.25)}
  input[type="range"]{width:160px}
  .muted{color:var(--muted);font-size:12px;margin-top:-6px;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <div class="stage" id="stage"><canvas id="cv"></canvas></div>
  <div class="controls">
    <label class="btn">🎵 おんがくフォルダ（連続再生）<input id="audDir" type="file" webkitdirectory directory multiple accept="audio/*" hidden></label>
    <button id="prev" class="btn">← まえ</button>
    <button id="play" class="btn">▶ / ❚❚</button>
    <button id="next" class="btn">つぎ →</button>
    <div class="range">かず <input id="count" type="range" min="3" max="50" step="1" value="22"></div>
    <div class="range">せんの太さ <input id="thick" type="range" min="2" max="14" step="1" value="6"></div>
    <div class="range">ひかり <input id="glow" type="range" min="8" max="60" step="1" value="28"></div>
  </div>
  <div class="muted">Baby Shapes Neon v1.2: 最低3つのモチーフ。背景ダークグレー。さわると全部が“はじき飛ぶ”。連続再生／PWA。</div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');
  const countUI = document.getElementById('count');
  const thickUI = document.getElementById('thick');
  const glowUI  = document.getElementById('glow');

  // ===== neon palette =====
  const COLORS = ["#39FF14","#00FFFF","#FF4D6D","#FFD166","#9D4DFF"]; // green, cyan, pink, yellow, purple
  const BG = "#1a1a1a";

  // ===== Audio (continuous) =====
  let audList=[], audIdx=0, audio=new Audio(); audio.preload="auto";
  let actx, analyser, data, playing=false;
  function ensureAudio(){
    if(actx) return;
    actx = new (window.AudioContext||window.webkitAudioContext)();
    const src = actx.createMediaElementSource(audio);
    analyser = actx.createAnalyser(); analyser.fftSize=256;
    data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser); analyser.connect(actx.destination);
  }
  function naturalSort(a,b){ return a.name.localeCompare(b.name,'ja',{numeric:true}); }
  document.getElementById('audDir').addEventListener('change', e=>{
    ensureAudio();
    audList = [...e.target.files].filter(f=>f.type.startsWith('audio/')).sort(naturalSort);
    audIdx=0; if(audList.length) playIndex(audIdx);
  });
  async function playIndex(i){
    if(!audList.length) return;
    audio.src = URL.createObjectURL(audList[i]);
    try{ if(actx.state!=="running") await actx.resume(); await audio.play(); playing=true; }catch(e){}
  }
  document.getElementById('next').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx+1)%audList.length; playIndex(audIdx); });
  document.getElementById('prev').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx-1+audList.length)%audList.length; playIndex(audIdx); });
  document.getElementById('play').addEventListener('click', async ()=>{
    ensureAudio(); if(actx.state!=="running") await actx.resume();
    if(audio.paused){ await audio.play(); playing=true; } else { audio.pause(); playing=false; }
  });
  audio.addEventListener('ended', ()=>{
    if(audList.length){ audIdx=(audIdx+1)%audList.length; playIndex(audIdx); }
    else { audio.currentTime=0; audio.play(); }
  });

  // ===== Canvas sizing =====
  const dprCap=1.25;
  function fit(){
    const s=Math.min(stage.clientWidth, stage.clientHeight);
    const dpr=Math.min(window.devicePixelRatio||1, dprCap);
    cv.width=cv.height=Math.max(360,Math.floor(s*dpr));
  }
  const ro=new ResizeObserver(()=>fit()); ro.observe(stage); fit();
  let lastDPR=window.devicePixelRatio; setInterval(()=>{ if(window.devicePixelRatio!==lastDPR){ lastDPR=window.devicePixelRatio; fit(); } }, 600);

  // ===== Shapes
  const TYPES = ["circle","triangle","square","star","heart"];
  function starPath(r, spikes=5){
    const p=new Path2D(); const step=Math.PI/spikes;
    p.moveTo(r,0);
    for(let i=0;i<spikes*2;i++){
      const rr = (i%2===0)? r : r*0.45;
      const a = i*step;
      p.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
    }
    p.closePath(); return p;
  }
  function heartPath(r){
    const p=new Path2D();
    p.moveTo(0,-r*0.2);
    p.bezierCurveTo(r*0.9,-r*0.9, r*1.4,r*0.5, 0,r*1.2);
    p.bezierCurveTo(-r*1.4,r*0.5, -r*0.9,-r*0.9, 0,-r*0.2);
    return p;
  }
  const starCache = new Map(); const heartCache = new Map();
  function getStar(r){ const k=r|0; if(!starCache.has(k)) starCache.set(k, starPath(k)); return starCache.get(k); }
  function getHeart(r){ const k=r|0; if(!heartCache.has(k)) heartCache.set(k, heartPath(k)); return heartCache.get(k); }

  const shapes=[];
  function resetShapes(){
    shapes.length=0;
    const raw = parseInt(countUI.value,10);
    const n = Math.max(3, raw|0); // 最低3つ
    for(let i=0;i<n;i++){
      const type=TYPES[i%TYPES.length];
      const r = 70*(0.6 + Math.random()*0.6);
      const x = Math.random()*cv.width;
      const y = Math.random()*cv.height;
      const rot = Math.random()*Math.PI*2;
      const vx = (Math.random()-0.5)*0.5;
      const vy = (Math.random()-0.5)*0.5;
      const color = COLORS[i%COLORS.length];
      shapes.push({type,x,y,r,rot,vx,vy,pulse:0,color});
    }
  }
  countUI.addEventListener('input', resetShapes);
  resetShapes();

  // interaction: scatter ALL on touch
  const chime = new Audio("./Chime.mp3"); chime.volume = 0.45;
  function toLocal(e){
    const r=stage.getBoundingClientRect();
    return { x:(e.clientX-r.left)/r.width*cv.width, y:(e.clientY-r.top)/r.height*cv.height };
  }
  stage.addEventListener('pointerdown', (e)=>{
    const p=toLocal(e);
    // 全部を外向きに弾く
    for(const s of shapes){
      const ang=Math.atan2(s.y-p.y, s.x-p.x);
      const force = 3.2 + Math.random()*1.8;
      s.vx += Math.cos(ang)*force;
      s.vy += Math.sin(ang)*force;
      s.pulse = Math.min(1, s.pulse + 0.9);
    }
    try{ chime.currentTime=0; chime.play(); }catch(_){}
    // 小さな光の輪
    sparks.push({x:p.x,y:p.y,t:0,color:"#ffffff"});
  });

  // motion (shake → scatter too)
  if (window.DeviceMotionEvent){
    let last=0;
    window.addEventListener('devicemotion', (e)=>{
      const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0;
      const s=Math.sqrt(x*x+y*y+z*z);
      if(s>18 && Date.now()-last>900){
        const cx=cv.width/2, cy=cv.height/2;
        for(const sh of shapes){
          const ang=Math.atan2(sh.y-cy, sh.x-cx);
          const force = 2.6 + Math.random()*1.6;
          sh.vx += Math.cos(ang)*force;
          sh.vy += Math.sin(ang)*force;
          sh.pulse = Math.min(1, sh.pulse+0.8);
        }
        try{ chime.currentTime=0; chime.play(); }catch(_){}
        sparks.push({x:cx,y:cy,t:0,color:"#ffffff"});
        last=Date.now();
      }
    }, {passive:true});
  }

  // spark rendering
  const sparks=[];

  // ===== draw
  let t=0;
  function draw(){
    const w=cv.width,h=cv.height;
    ctx.fillStyle=BG; ctx.fillRect(0,0,w,h);

    // audio energy
    let low=0, mid=0, hi=0;
    if(analyser && playing){
      analyser.getByteFrequencyData(data);
      const n=data.length;
      for(let i=0;i<n;i++){
        const v=data[i]/255;
        if(i<n*0.33) low+=v; else if(i<n*0.66) mid+=v; else hi+=v;
      }
      low/=n*0.33; mid/=n*0.33; hi/=n*0.34;
    }

    const lineBase = parseFloat(thickUI.value);
    const glow = parseFloat(glowUI.value);

    for(const s of shapes){
      s.x+=s.vx; s.y+=s.vy; s.rot+=0.008*(0.6+mid);
      // 画面内で跳ね返る
      if(s.x<s.r){ s.x=s.r; s.vx=Math.abs(s.vx); }
      if(s.x>w-s.r){ s.x=w-s.r; s.vx=-Math.abs(s.vx); }
      if(s.y<s.r){ s.y=s.r; s.vy=Math.abs(s.vy); }
      if(s.y>h-s.r){ s.y=h-s.r; s.vy=-Math.abs(s.vy); }
      // 摩擦
      s.vx*=0.992; s.vy*=0.992;

      // 呼吸 + パルス + 高域きらめき
      const scale = 1 + 0.07*Math.sin(t*0.03 + s.x*0.003) + s.pulse*0.25 + hi*0.1;
      const r = s.r * scale;
      s.pulse *= 0.92;

      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.rot);

      ctx.lineJoin="round"; ctx.lineCap="round";
      ctx.shadowColor = s.color; ctx.shadowBlur = glow*2;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = lineBase*2.4;
      drawShapeStroke(s.type, r);

      ctx.shadowBlur = glow;
      ctx.lineWidth = lineBase*1.5;
      drawShapeStroke(s.type, r);

      ctx.shadowBlur = glow*0.3;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = Math.max(1, lineBase*0.6);
      drawShapeStroke(s.type, r);

      ctx.restore();
    }

    // sparks
    for(let i=sparks.length-1;i>=0;i--){
      const sp=sparks[i]; sp.t+=0.03;
      const rr=20 + sp.t*140; const a=Math.max(0, 0.35 - sp.t*0.25);
      if(a<=0){ sparks.splice(i,1); continue; }
      const grd = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, rr);
      grd.addColorStop(0, `rgba(255,255,255,${a})`);
      grd.addColorStop(1, `rgba(255,255,255,0)`);
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(sp.x, sp.y, rr, 0, Math.PI*2); ctx.fill();
    }

    t += 1;
    requestAnimationFrame(draw);
  }

  function drawShapeStroke(type, r){
    switch(type){
      case "circle": ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); break;
      case "triangle":
        ctx.beginPath();
        const htri = r*1.1;
        ctx.moveTo(0,-htri);
        ctx.lineTo(htri*Math.sin(Math.PI/3), htri*Math.cos(Math.PI/3));
        ctx.lineTo(-htri*Math.sin(Math.PI/3), htri*Math.cos(Math.PI/3));
        ctx.closePath(); ctx.stroke(); break;
      case "square": ctx.strokeRect(-r,-r,r*2,r*2); break;
      case "star": ctx.stroke(getStar(r)); break;
      case "heart": ctx.stroke(getHeart(r)); break;
    }
  }

  // cache paths
  function starPath(r, spikes=5){
    const p=new Path2D(); const step=Math.PI/spikes;
    p.moveTo(r,0);
    for(let i=0;i<spikes*2;i++){
      const rr = (i%2===0)? r : r*0.45;
      const a = i*step;
      p.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
    }
    p.closePath(); return p;
  }
  function heartPath(r){
    const p=new Path2D();
    p.moveTo(0,-r*0.2);
    p.bezierCurveTo(r*0.9,-r*0.9, r*1.4,r*0.5, 0,r*1.2);
    p.bezierCurveTo(-r*1.4,r*0.5, -r*0.9,-r*0.9, 0,-r*0.2);
    return p;
  }
  const starCache = new Map(); const heartCache = new Map();
  function getStar(r){ const k=r|0; if(!starCache.has(k)) starCache.set(k, starPath(k)); return starCache.get(k); }
  function getHeart(r){ const k=r|0; if(!heartCache.has(k)) heartCache.set(k, heartPath(k)); return heartCache.get(k); }

  requestAnimationFrame(draw);
})();
</script>
<script>
if("serviceWorker" in navigator){ navigator.serviceWorker.register("./sw.js?v=1.2"); }
</script>
</body>
</html>
