<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>四角い穴の下で大円盤が回る（音楽連動・クリックブースト最終版）</title>
<style>
  :root{--bg:#0b0d11;--fg:#e8f0ff;--muted:#9fb6d9}
  html,body{height:100%;margin:0;background:#0b0d11;color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto;justify-items:center;align-items:center}
  .stage{position:relative;display:grid;place-items:center;width:100%;height:100%}
  canvas{display:block;position:absolute;inset:0;margin:auto}
  #box{position:relative;aspect-ratio:1/1;width:min(92vmin, calc(100vw - 32px));}
  #bg,#mask{width:100%;height:100%}
  .bar{width:100%;display:flex;gap:.6rem;flex-wrap:wrap;align-items:center;justify-content:center;padding:.7rem;background:linear-gradient(180deg, rgba(14,18,24,.55), rgba(14,18,24,.95));backdrop-filter:blur(6px);border-top:1px solid #1c2635}
  .btn{background:#0f1a27;border:1px solid #263244;color:var(--fg);padding:.55rem .8rem;border-radius:.8rem;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  input[type=file]{display:none}
  label.file{cursor:pointer}
  .group{display:inline-flex;align-items:center;gap:.35rem}
  .pill{color:var(--muted);font-size:.9rem}
</style>
</head>
<body>
<div id="wrap">
  <div class="stage">
    <div id="box">
      <!-- 下：回転する円盤 -->
      <canvas id="bg" width="1024" height="1024"></canvas>
      <!-- 上：黒い板（中央は四角い穴・透過） -->
      <canvas id="mask" width="1024" height="1024"></canvas>
    </div>
  </div>

  <div class="bar">
    <input id="imgFile" type="file" accept="image/*">
    <label for="imgFile" class="btn file">📷 画像</label>
    <button id="testImgBtn" class="btn">🧪 テスト画像</button>
    <button id="clearImg" class="btn">画像クリア</button>

    <div class="group">
      <label>分割 N×N</label>
      <input id="gridN" type="range" min="1" max="32" value="12">
      <span id="gridNV">12</span>
    </div>
    <div class="group">
      <label>放射セグメント</label>
      <input id="segs" type="range" min="6" max="96" value="36">
      <span id="segsV">36</span>
    </div>
    <div class="group">
      <label>穴サイズ</label>
      <input id="hole" type="range" min="50" max="98" value="86">
      <span id="holeV">86%</span>
    </div>

    <!-- 音楽：単体 or フォルダ -->
    <input id="musicFile" type="file" accept="audio/*">
    <label for="musicFile" class="btn file">🎵 音楽ファイル</label>
    <input id="musicDir" type="file" webkitdirectory multiple accept="audio/*">
    <label for="musicDir" class="btn file">📁 音楽フォルダ</label>
    <button id="prevTrack" class="btn">⟵ 前</button>
    <button id="nextTrack" class="btn">次 ⟶</button>
    <span id="trackInfo" class="pill"></span>
    <button id="playPause" class="btn">▶ 再生/一時停止</button>

    <label class="group"><input type="checkbox" id="chimeOn" checked> 🔔キャンバスクリックでChime</label>
  </div>
</div>

<script>
/* ========= Canvas ========= */
const bg = document.getElementById('bg'); const bk = bg.getContext('2d');
const mask = document.getElementById('mask'); const mk = mask.getContext('2d');
const gridNEl = document.getElementById('gridN'), gridNV = document.getElementById('gridNV');
const segsEl = document.getElementById('segs'), segsV = document.getElementById('segsV');
const holeEl = document.getElementById('hole'), holeV = document.getElementById('holeV');
const chimeOn = document.getElementById('chimeOn');

let GRID = +gridNEl.value;
let SEGS = +segsEl.value;
let HOLE = +holeEl.value; // % of side

/* ========= Audio (music + chime + analyser) ========= */
let audioCtx=null, analyser=null, musicSrcNode=null;
const chime = new Audio('https://raw.githubusercontent.com/Masato-Nasu/KB/main/Chime.mp3');
const music = new Audio(); music.loop = false; music.crossOrigin = 'anonymous';

async function ensureAC(){
  if(!audioCtx){ const AC = window.AudioContext || window.webkitAudioContext; audioCtx = new AC(); }
  if(audioCtx.state === 'suspended') await audioCtx.resume();
  if(!analyser){
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;
  }
  if(!musicSrcNode){
    musicSrcNode = audioCtx.createMediaElementSource(music);
    musicSrcNode.connect(analyser); analyser.connect(audioCtx.destination);
  }
}

function attachClick(el){
  el.addEventListener('click', async ()=>{
    triggerBoost(); // 動きブースト
    if (!chimeOn.checked) return;
    try{
      await ensureAC();
      chime.currentTime = 0;
      await chime.play();
    }catch(e){ console.warn('chime failed', e); }
  }, {passive:true});
}
attachClick(bg);
attachClick(mask);

/* ========= Playlist（数字→50音） ========= */
const musicFile = document.getElementById('musicFile');
const musicDir = document.getElementById('musicDir');
const prevBtn = document.getElementById('prevTrack');
const nextBtn = document.getElementById('nextTrack');
const trackInfo = document.getElementById('trackInfo');
const playPause = document.getElementById('playPause');

const collatorJA = new Intl.Collator('ja', {numeric:true, sensitivity:'base'});
const AUDIO_OK = new Set(['.mp3','.m4a','.wav','.ogg','.aac','.flac']);

let playlist = []; let trackIdx = -1;

function isAudio(name){ const i=name.lastIndexOf('.'); const ext=(i>=0?name.slice(i).toLowerCase():''); return AUDIO_OK.has(ext); }
function setTrackInfo(){ trackInfo.textContent = (trackIdx>=0&&playlist[trackIdx]) ? `${trackIdx+1}/${playlist.length}  ${playlist[trackIdx].name}` : ''; }
function loadTrack(i){
  if(!playlist.length) return;
  trackIdx = (i + playlist.length) % playlist.length;
  const f = playlist[trackIdx]; music.src = URL.createObjectURL(f); setTrackInfo();
}
async function playCurrent(){ try{ await ensureAC(); await music.play(); }catch(e){ alert('再生できませんでした。もう一度▶を押してください。\n'+e); } }
function nextTrack(){ if(!playlist.length) return; loadTrack(trackIdx+1); playCurrent(); }
function prevTrack(){ if(!playlist.length) return; loadTrack(trackIdx-1); playCurrent(); }

musicFile.addEventListener('change', async e=>{
  const f = e.target.files[0]; if(!f) return;
  playlist=[f]; trackIdx=-1; await ensureAC(); nextTrack();
});
musicDir.addEventListener('change', async e=>{
  const files = Array.from(e.target.files).filter(f=>isAudio(f.name));
  files.sort((a,b)=>collatorJA.compare(a.name,b.name));
  playlist = files; trackIdx=-1; await ensureAC(); nextTrack();
});
playPause.addEventListener('click', async ()=>{ await ensureAC(); try{ if(music.paused) await music.play(); else music.pause(); }catch(e){ alert('再生がブロックされました。もう一度▶を押してください。\n'+e); } });
prevBtn.addEventListener('click', prevTrack);
nextBtn.addEventListener('click', nextTrack);
music.addEventListener('ended', nextTrack);

/* ========= Image pattern (N×N mirror) ========= */
let baseImg=null, pat=null, pctx=null;

function coverSrc(iw,ih,dw,dh,dx=0,dy=0,zoom=1){
  const s=Math.max(dw/iw, dh/ih)*zoom;
  const vw=dw/s, vh=dh/s;
  const mx=Math.max(0,(iw-vw)/2), my=Math.max(0,(ih-vh)/2);
  const sx=(iw-vw)/2 + Math.max(-mx,Math.min(mx,dx*mx));
  const sy=(ih-vh)/2 + Math.max(-my,Math.min(my,dy*my));
  return {sx,sy,sw:vw,sh:vh};
}

let driftBoost=0;            // 0→1
const boostPower=1.6;        // 動きの強さ
let boostUntil=0;            // ブースト終了時刻(ms)

function triggerBoost(){ driftBoost=1; boostUntil=performance.now()+1800; }

function rebuildPattern(){
  if(!baseImg) return;
  const w=bg.width, h=bg.height;
  if(!pat){ pat=document.createElement('canvas'); pctx=pat.getContext('2d'); }
  pat.width=w; pat.height=h;

  // ドリフト＆ズーム（ブーストで強化）
  const t=performance.now();
  const bf = 1 + 0.9*driftBoost*boostPower;
  const dx=Math.sin(t*0.00023*bf)*0.9*bf;
  const dy=Math.cos(t*0.00019*bf)*0.9*bf;
  const zoom=1 + (0.06*bf)*Math.sin(t*0.00011*bf);

  const src=coverSrc(baseImg.width, baseImg.height, w, h, dx, dy, zoom);

  const tw=w/GRID, th=h/GRID, sw=src.sw/GRID, sh=src.sh/GRID;
  pctx.clearRect(0,0,w,h);
  for(let gy=0; gy<GRID; gy++){
    for(let gx=0; gx<GRID; gx++){
      const dxp=gx*tw, dyp=gy*th, sxi=src.sx+gx*sw, syi=src.sy+gy*sh;
      pctx.save();
      pctx.translate(dxp+tw/2, dyp+th/2);
      pctx.scale(gx%2?-1:1, gy%2?-1:1);
      pctx.drawImage(baseImg, sxi, syi, sw, sh, -tw/2, -th/2, tw, th);
      pctx.restore();
    }
  }
}

/* ========= Draw big disc UNDER square hole ========= */
let angle=0;
function draw(){
  const w=bg.width, h=bg.height;
  bk.clearRect(0,0,w,h);

  if(pat){
    const cx=w/2, cy=h/2;
    const slice=(Math.PI*2)/SEGS;

    // 穴の一辺（px）
    const holeSide = Math.min(w,h) * (HOLE/100);
    // 穴の対角の半分（これ以上なら四隅に必ず届く）
    const rByHole = holeSide / Math.SQRT2 + 12;     // 12pxの余裕マージン
    // キャンバス対角基準（過度に小さくならない下限）
    const rByCanvas = Math.hypot(w,h) * 0.64;       // 好みで 0.60〜0.70
    // 最終半径
    const R = Math.max(rByHole, rByCanvas);
    const wedgeR = Math.hypot(w,h);

    bk.save();
    bk.translate(cx,cy);

    // 円盤クリップ
    bk.beginPath(); bk.arc(0,0,R,0,Math.PI*2); bk.clip();

    for(let i=0;i<SEGS;i++){
      bk.save();
      bk.rotate(i*slice + angle);
      bk.beginPath();
      bk.moveTo(0,0);
      bk.lineTo(wedgeR, -wedgeR*Math.tan(slice/2));
      bk.lineTo(wedgeR,  wedgeR*Math.tan(slice/2));
      bk.closePath(); bk.clip();
      const flip=(i%2===1)?-1:1;
      bk.scale(flip,1);
      bk.drawImage(pat, -w/2, -h/2, w, h);
      bk.restore();
    }
    bk.restore();
  }

  // 上の黒板に四角い穴
  mk.clearRect(0,0,w,h);
  mk.save();
  mk.fillStyle='#000'; mk.fillRect(0,0,w,h);
  mk.globalCompositeOperation='destination-out';
  const side = Math.floor(Math.min(w,h)*(HOLE/100));
  mk.fillRect((w-side)/2,(h-side)/2,side,side);
  mk.restore();

  // 音楽の振幅 → 回転速度
  const baseSpeed = 0.0025*(36/Math.max(12,SEGS));
  let audioBoost = 0;
  if(analyser){
    const bins = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(bins);
    const n = Math.max(8, Math.floor(bins.length*0.12)); // 低域寄り
    let s=0; for(let i=0;i<n;i++) s+=bins[i];
    const rms = s/(n*255);           // 0..1
    audioBoost = rms * 0.10;         // 反応を強めに
  }
  const clickBoost = 0.06*driftBoost; // クリック一時加速
  angle += baseSpeed + audioBoost + clickBoost;

  // ブースト減衰
  const now = performance.now();
  if(driftBoost>0){
    if(now>boostUntil) driftBoost=0;
    else driftBoost = Math.max(0, driftBoost - 0.018);
  }

  requestAnimationFrame(tick);
}

function tick(){ if(baseImg) rebuildPattern(); draw(); }

/* ========= Fit ========= */
function fit(){
  const ratio = Math.min(window.innerWidth, window.innerHeight-92);
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const px = Math.floor(ratio * dpr);
  bg.width=bg.height=mask.width=mask.height=px;
  bg.style.width=bg.style.height=mask.style.width=mask.style.height=(ratio)+'px';
}
addEventListener('resize', fit); fit();

/* ========= Image loaders ========= */
function loadImgFile(f){
  if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = ()=>{ baseImg=im; URL.revokeObjectURL(url); };
  im.src = url;
}
document.getElementById('imgFile').addEventListener('change', e=>loadImgFile(e.target.files[0]));
document.getElementById('testImgBtn').addEventListener('click', ()=>{
  const svg=`<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="1024" viewBox="0 0 1024 1024">
    <defs>
      <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#fff"/><stop offset="50%" stop-color="#f7b65a"/><stop offset="100%" stop-color="#3aa0ff"/>
      </linearGradient>
      <pattern id="p" width="64" height="64" patternUnits="userSpaceOnUse">
        <rect width="64" height="64" fill="url(#g)"/>
        <path d="M0 32 H64 M32 0 V64" stroke="rgba(0,0,0,.18)" stroke-width="2"/>
      </pattern>
    </defs>
    <rect width="1024" height="1024" fill="url(#p)"/></svg>`;
  const url='data:image/svg+xml;utf8,'+encodeURIComponent(svg);
  const im=new Image(); im.onload=()=>{ baseImg=im; }; im.src=url;
});
document.getElementById('clearImg').addEventListener('click', ()=>{ baseImg=null; pat=null; });

/* ========= UI ========= */
gridNEl.addEventListener('input', ()=>{ GRID=+gridNEl.value; gridNV.textContent=GRID; });
segsEl.addEventListener('input', ()=>{ SEGS=+segsEl.value; segsV.textContent=SEGS; });
holeEl.addEventListener('input', ()=>{ HOLE=+holeEl.value; holeV.textContent=HOLE+'%'; });

/* ========= Boot ========= */
document.getElementById('testImgBtn').click();
requestAnimationFrame(tick);
</script>
</body>
</html>
