<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Baby Shapes Neon — 再生モード付き (v1.3)</title>
<link rel="manifest" href="./manifest.json?v=1.3">
<meta name="theme-color" content="#1a1a1a">
<style>
  :root{ --bg:#1a1a1a; --panel:#20232bcc; --text:#E8EAF2; --muted:#8b90a1; --boxw:1100px; --pad:16px;}
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Roboto,"Noto Sans JP",sans-serif;}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;min-height:100%; padding:12px}
  .box{ width: min(var(--boxw), calc(100% - 2*var(--pad))); margin:0 auto; border-radius:24px; overflow:hidden; box-shadow:0 12px 36px rgba(0,0,0,.35); }
  .stage{ position:relative; display:grid; place-items:center; aspect-ratio:1; background:var(--bg); }
  canvas{width:100%;height:100%;display:block;touch-action:none;background:var(--bg)}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center; padding:12px; background:var(--panel); backdrop-filter:saturate(1.05) blur(6px); transition:opacity .25s ease, visibility .25s ease;}
  .btn{appearance:none;border:0;border-radius:14px;background:#2f6feb;color:#fff; padding:12px 16px;font-size:16px;display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .range{display:inline-flex;align-items:center;gap:10px;background:#0f1117; color:#E8EAF2; border-radius:14px;padding:10px 12px; box-shadow:0 2px 8px rgba(0,0,0,.25)}
  input[type="range"]{width:160px}
  .muted{color:var(--muted);font-size:12px;margin-top:-6px;text-align:center}
  /* 再生モード（全画面） */
  .fullscreen .wrap{padding:0}
  .fullscreen .box{width:100%; border-radius:0; box-shadow:none;}
  .fullscreen .stage{aspect-ratio:auto; width:100vw; height:100vh;}
  .hidden{opacity:0; visibility:hidden; pointer-events:none}
  .topbar{position:fixed; top:10px; right:10px; z-index:10; display:flex; gap:8px}
</style>
</head>
<body>
<div class="topbar">
  <button id="playMode" class="btn">🖥️ 再生モード</button>
  <button id="showCtrl" class="btn">⚙️ 設定</button>
</div>
<div class="wrap">
  <div class="box"><div class="stage" id="stage"><canvas id="cv"></canvas></div></div>
  <div class="box">
    <div class="controls" id="controls">
      <label class="btn">🎵 おんがくフォルダ<input id="audDir" type="file" webkitdirectory directory multiple accept="audio/*" hidden></label>
      <button id="prev" class="btn">← まえ</button>
      <button id="play" class="btn">▶ / ❚❚</button>
      <button id="next" class="btn">つぎ →</button>
      <div class="range">かず <input id="count" type="range" min="3" max="50" step="1" value="22"></div>
      <div class="range">せんの太さ <input id="thick" type="range" min="2" max="14" step="1" value="6"></div>
      <div class="range">ひかり <input id="glow" type="range" min="8" max="60" step="1" value="28"></div>
    </div>
  </div>
  <div class="muted">v1.3: 全画面の再生モード＋設定UIの自動非表示。最低3つ／ダーク背景／PWA。</div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');
  const controls = document.getElementById('controls');
  const countUI = document.getElementById('count');
  const thickUI = document.getElementById('thick');
  const glowUI  = document.getElementById('glow');

  // --- 再生モード（全画面）＆UI自動非表示 ---
  const playModeBtn = document.getElementById('playMode');
  const showCtrlBtn = document.getElementById('showCtrl');
  let autoHideTimer=null;
  function hideControls(){ controls.classList.add('hidden'); }
  function showControls(){ controls.classList.remove('hidden'); restartAutoHide(); }
  function restartAutoHide(){
    if(document.fullscreenElement){ // 全画面時のみ自動非表示
      if(autoHideTimer) clearTimeout(autoHideTimer);
      autoHideTimer = setTimeout(hideControls, 2500);
    }
  }
  playModeBtn.addEventListener('click', async ()=>{
    if(!document.fullscreenElement){
      await document.documentElement.requestFullscreen().catch(()=>{});
      document.body.classList.add('fullscreen');
      restartAutoHide();
    }else{
      await document.exitFullscreen().catch(()=>{});
      document.body.classList.remove('fullscreen');
      controls.classList.remove('hidden');
    }
  });
  showCtrlBtn.addEventListener('click', showControls);
  document.addEventListener('pointermove', ()=>{ if(document.fullscreenElement){ showControls(); }}, {passive:true});
  document.addEventListener('pointerdown', ()=>{ if(document.fullscreenElement){ restartAutoHide(); }}, {passive:true});

  // palette
  const COLORS = ["#39FF14","#00FFFF","#FF4D6D","#FFD166","#9D4DFF"];
  const BG = "#1a1a1a";

  // ===== Audio (continuous) =====
  let audList=[], audIdx=0, audio=new Audio(); audio.preload="auto";
  let actx, analyser, data, playing=false;
  function ensureAudio(){
    if(actx) return;
    actx = new (window.AudioContext||window.webkitAudioContext)();
    const src = actx.createMediaElementSource(audio);
    analyser = actx.createAnalyser(); analyser.fftSize=256;
    data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser); analyser.connect(actx.destination);
  }
  ['click','touchstart','pointerdown'].forEach(ev=>{
    window.addEventListener(ev, async ()=>{ ensureAudio(); try{ if(actx.state!=='running') await actx.resume(); }catch(_){ } }, {once:true, passive:true});
  });
  function naturalSort(a,b){ return a.name.localeCompare(b.name,'ja',{numeric:true}); }
  document.getElementById('audDir').addEventListener('change', e=>{
    ensureAudio();
    audList = [...e.target.files].filter(f=>f.type.startsWith('audio/')).sort(naturalSort);
    audIdx=0; if(audList.length) playIndex(audIdx);
  });
  async function playIndex(i){
    if(!audList.length) return;
    audio.src = URL.createObjectURL(audList[i]);
    try{ if(actx.state!=='running') await actx.resume(); await audio.play(); playing=true; }catch(e){}
  }
  document.getElementById('next').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx+1)%audList.length; playIndex(audIdx); });
  document.getElementById('prev').addEventListener('click',()=>{ if(!audList.length)return; audIdx=(audIdx-1+audList.length)%audList.length; playIndex(audIdx); });
  document.getElementById('play').addEventListener('click', async ()=>{
    ensureAudio(); if(actx.state!=='running') await actx.resume();
    if(audio.paused){ await audio.play(); playing=true; } else { audio.pause(); playing=false; }
  });
  audio.addEventListener('ended', ()=>{
    if(audList.length){ audIdx=(audIdx+1)%audList.length; playIndex(audIdx); }
    else { audio.currentTime=0; audio.play(); }
  });

  // ===== Canvas sizing
  const dprCap=1.25;
  function fit(){
    const s=Math.min(stage.clientWidth, stage.clientHeight);
    const dpr=Math.min(window.devicePixelRatio||1, dprCap);
    cv.width=cv.height=Math.max(360,Math.floor(s*dpr));
  }
  const ro=new ResizeObserver(()=>fit()); ro.observe(stage); fit();
  let lastDPR=window.devicePixelRatio; setInterval(()=>{ if(window.devicePixelRatio!==lastDPR){ lastDPR=window.devicePixelRatio; fit(); } }, 600);

  // ===== Shapes
  const TYPES = ["circle","triangle","square","star","heart"];
  function starPath(r, spikes=5){ const p=new Path2D(); const step=Math.PI/spikes; p.moveTo(r,0); for(let i=0;i<spikes*2;i++){ const rr=(i%2===0)?r:r*0.45; const a=i*step; p.lineTo(Math.cos(a)*rr,Math.sin(a)*rr);} p.closePath(); return p; }
  function heartPath(r){ const p=new Path2D(); p.moveTo(0,-r*0.2); p.bezierCurveTo(r*0.9,-r*0.9, r*1.4,r*0.5, 0,r*1.2); p.bezierCurveTo(-r*1.4,r*0.5, -r*0.9,-r*0.9, 0,-r*0.2); return p; }
  const starCache=new Map(), heartCache=new Map();
  function getStar(r){ const k=r|0; if(!starCache.has(k)) starCache.set(k, starPath(k)); return starCache.get(k); }
  function getHeart(r){ const k=r|0; if(!heartCache.has(k)) heartCache.set(k, heartPath(k)); return heartCache.get(k); }

  const shapes=[];
  function resetShapes(){
    shapes.length=0;
    const n=Math.max(3, (countUI.value|0));
    for(let i=0;i<n;i++){
      const type=TYPES[i%TYPES.length];
      const r=70*(0.6+Math.random()*0.6);
      const x=Math.random()*cv.width, y=Math.random()*cv.height;
      const rot=Math.random()*Math.PI*2;
      const vx=(Math.random()-0.5)*0.5, vy=(Math.random()-0.5)*0.5;
      const color=COLORS[i%COLORS.length];
      shapes.push({type,x,y,r,rot,vx,vy,pulse:0,color});
    }
  }
  countUI.addEventListener('input', resetShapes); resetShapes();

  // interaction: scatter ALL on touch
  const chime = new Audio("./Chime.mp3"); chime.volume = 0.45;
  function toLocal(e){ const r=stage.getBoundingClientRect(); return { x:(e.clientX-r.left)/r.width*cv.width, y:(e.clientY-r.top)/r.height*cv.height }; }
  stage.addEventListener('pointerdown', (e)=>{
    const p=toLocal(e);
    for(const s of shapes){
      const ang=Math.atan2(s.y-p.y, s.x-p.x);
      const force=3.2 + Math.random()*1.8;
      s.vx += Math.cos(ang)*force; s.vy += Math.sin(ang)*force;
      s.pulse = Math.min(1, s.pulse+0.9);
    }
    try{ chime.currentTime=0; chime.play(); }catch(_){}
  });

  // sparks omitted（軽量化）

  // ===== draw
  let t=0;
  function draw(){
    const w=cv.width,h=cv.height;
    ctx.fillStyle=BG; ctx.fillRect(0,0,w,h);
    let low=0,mid=0,hi=0;
    if(analyser){ analyser.getByteFrequencyData(data); const n=data.length; for(let i=0;i<n;i++){ const v=data[i]/255; if(i<n*0.33) low+=v; else if(i<n*0.66) mid+=v; else hi+=v; } low/=n*0.33; mid/=n*0.33; hi/=n*0.34; }
    const lineBase=parseFloat(thickUI.value); const glow=parseFloat(glowUI.value);
    for(const s of shapes){
      s.x+=s.vx; s.y+=s.vy; s.rot+=0.008*(0.6+mid);
      if(s.x<s.r){ s.x=s.r; s.vx=Math.abs(s.vx); } if(s.x>w-s.r){ s.x=w-s.r; s.vx=-Math.abs(s.vx); }
      if(s.y<s.r){ s.y=s.r; s.vy=Math.abs(s.vy); } if(s.y>h-s.r){ s.y=h-s.r; s.vy=-Math.abs(s.vy); }
      s.vx*=0.992; s.vy*=0.992;
      const scale = 1 + 0.07*Math.sin(t*0.03 + s.x*0.003) + s.pulse*0.25 + hi*0.1;
      const r = s.r * scale; s.pulse *= 0.92;
      ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rot);
      ctx.lineJoin="round"; ctx.lineCap="round";
      ctx.shadowColor=s.color; ctx.shadowBlur=glow*2; ctx.strokeStyle=s.color; ctx.lineWidth=lineBase*2.4; drawShapeStroke(s.type,r);
      ctx.shadowBlur=glow; ctx.lineWidth=lineBase*1.5; drawShapeStroke(s.type,r);
      ctx.shadowBlur=glow*0.3; ctx.strokeStyle="#ffffff"; ctx.lineWidth=Math.max(1,lineBase*0.6); drawShapeStroke(s.type,r);
      ctx.restore();
    }
    t++; requestAnimationFrame(draw);
  }
  function drawShapeStroke(type,r){
    switch(type){
      case "circle": ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); break;
      case "triangle": ctx.beginPath(); const h=r*1.1; ctx.moveTo(0,-h); ctx.lineTo(h*Math.sin(Math.PI/3), h*Math.cos(Math.PI/3)); ctx.lineTo(-h*Math.sin(Math.PI/3), h*Math.cos(Math.PI/3)); ctx.closePath(); ctx.stroke(); break;
      case "square": ctx.strokeRect(-r,-r,r*2,r*2); break;
      case "star": ctx.stroke(getStar(r)); break;
      case "heart": ctx.stroke(getHeart(r)); break;
    }
  }
  requestAnimationFrame(draw);
})();
</script>
<script>
if("serviceWorker" in navigator){ navigator.serviceWorker.register("./sw.js?v=1.3"); }
</script>
</body>
</html>
